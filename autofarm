local lp = game.Players.LocalPlayer
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CleaningEvent = ReplicatedStorage.MoppingRemote
local UserInputService = game:GetService("UserInputService")



for _,part in pairs(game.Workspace:GetDescendants()) do
    if part:IsA("BasePart") and (part.Name == "BenchSeat" or part.Name == "Seat" or part.Name == "PrioritySeat" or part.Name == "BackSeats") then
        part:Destroy()
    end
end

local function equipTool(toolName)
    local tool
    if game.Players.LocalPlayer.Backpack:FindFirstChild("GoldenMop") then
        tool = game.Players.LocalPlayer.Backpack:FindFirstChild("GoldenMop")
    else
        tool = game.Players.LocalPlayer.Backpack:FindFirstChild(toolName) or game.Players.LocalPlayer.Character:FindFirstChild(toolName)
    end
    if tool then
        game.Players.LocalPlayer.Character.Humanoid:EquipTool(tool)
    end
end

equipTool("Mop")

lp.Character.HumanoidRootPart.CFrame = CFrame.new(-6.3302331, 0.694394946, -368.500946)

wait(3.5)

local function getSpill()
    local dist, thing = math.huge
    local success, workspace = pcall(function() return game:GetService("Workspace") end)
    if not success then
        error("Failed to access Workspace")
    end
    local spills = workspace.SpillAssets.Spills
    if not spills then
        error("Failed to access Spills")
    end
    for i, v in pairs(spills:GetChildren()) do
        if v.Name == "Spill" then
            -- Check if the spill has a group of models called "WetFloorSign" inside of it, and skip it if it does
            local hasWetFloorSign = false
            for _, child in ipairs(v:GetChildren()) do
                if child.Name == "WetFloorSign" and child:IsA("Model") then
                    hasWetFloorSign = true
                    break
                end
            end

            if not hasWetFloorSign then
                local humanoidRootPart = game.Players.LocalPlayer.Character.HumanoidRootPart
                if not humanoidRootPart then
                    error("Failed to access HumanoidRootPart")
                end
                local mag = math.abs(humanoidRootPart.Position.Y - v.Position.Y)
                if mag < dist then 
                    dist = mag 
                    thing = v 
                end
            end
        end
    end
    return thing
end


local function noclip()
    for i, v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
        if v:IsA("BasePart") and v.CanCollide == true then
            v.CanCollide = false
            game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
        end
    end
end

local function moveTo(obj, speed)
    local humanoidRootPart = game.Players.LocalPlayer.Character.HumanoidRootPart
    local info = TweenInfo.new(((humanoidRootPart.Position - obj.Position).Magnitude) / speed, Enum.EasingStyle.Linear)
    local tween = TweenService:Create(humanoidRootPart, info, {CFrame = obj})

    local antiFall = Instance.new("BodyVelocity", humanoidRootPart)
    antiFall.Velocity = Vector3.new(0, 0, 0)

    local noClipConnection = RunService.Stepped:Connect(noclip)
    tween:Play()
    
    tween.Completed:Wait() -- wait for the tween to complete before allowing movement again
    
    antiFall:Destroy()
    noClipConnection:Disconnect()
end


local lastSpill = nil
local isMoving = false
local canMove = true

CleaningEvent.OnClientEvent:Connect(function(spillObj)
    if spillObj and spillObj.Parent and spillObj.Parent.Name == "Spills" and spillObj.Name == "Spill" then
        if lastSpill == spillObj then
            lastSpill = nil
            canMove = true
        end
        canMove = false
    end
end)


while true do
    local currentSpill = getSpill()
    if currentSpill ~= lastSpill then
        if currentSpill then
            lastSpill = currentSpill
            local offset = Vector3.new(0, currentSpill.Size.Y / 50, 0) -- adjust offset
            moveTo(lastSpill.CFrame + offset, 100)
        else
            -- set default tween object here
            local defaultTweenObject = game:GetService("Workspace").Loadables.Downstairs.Part
            local offset = Vector3.new(0, defaultTweenObject.Size.Y / 50, 0) -- adjust offset
            moveTo(defaultTweenObject.CFrame + offset, 100)
            lastSpill = nil
        end
    end
    
    if lastSpill and not lastSpill:IsDescendantOf(game:GetService("Workspace").SpillAssets.Spills) then
        lastSpill = nil
        canMove = true
    end
    
    if lastSpill and lastSpill.Parent and lastSpill.Parent.Name == "Spills" and lastSpill.Name == "Spill" then
        local humanoidRootPart = game.Players.LocalPlayer.Character.HumanoidRootPart
        local mag = (humanoidRootPart.Position - lastSpill.Position).Magnitude
        if mag > 3 then -- modify the threshold to adjust distance to spill
            canMove = false
            local offset = Vector3.new(0, lastSpill.Size.Y / 5, 0) -- adjust offset
            moveTo(lastSpill.CFrame + offset, 100)
        else
            canMove = true
        end
    end
    
    wait(0.1)
end


CleaningEvent:FireServer(lastSpill)

if lastSpill then
    lp.Character.HumanoidRootPart.CFrame = lastSpill.CFrame + Vector3.new(0, 5, 0)
end
